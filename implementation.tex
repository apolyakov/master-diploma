\section{Архитектура и особенности реализации}
В данном разделе представлены архитектурные решения разрабатываемого языка и
и некоторые особенности их реализации.

\subsection{Архитектурные решения}
\label{section:architecture}
В ходе данной работы, выбор тех или иных архитектурных решений был
мотивирован удовлетворением итогового результата работы всем собранным
в главе~\ref{requirements-section} требованиям к спецификации и компилятору
современного языка разработки мобильных приложений.

\subsubsection{Встраивание  предметного языка в язык программирования \name{Accord}}
Язык разработки мобильных приложений является примером
предметно-ориентированного языка. В качестве способа реализации такого языка
был выбран метод встраивания предметного языка в базовый, которым является
язык \name{Accord}. Такое решение позволило переиспользовать существующий
прототип компилятора и спецификацию языка \name{Accord}, включая синтаксис,
синтаксический и семантический анализаторы, оптимизатор высокоуровневого
промежуточного представления, кодогенерации в \name{LLVM IR} и байткод
некоторой виртуальной машины.

Следствием этого решения является тот факт, что все синтаксические и
семантические конструкции и правила являются общими как для разработки
мобильных интерфейсов, так и для программ общего назначения. Другим
следствием является автоматическое соответствие решения таким требованиям,
как:
\begin{itemize}
	\item кроссплатформенная разработка: наличие кодогенерации в
	\name{LLVM IR} означает возможность потенциального запуска мобильных
	приложений, написанных на языке \name{Accord}, на всех платформах,
	поддерживаемых проектом \name{LLVM}~\cite{llvm-homepage}, а также
	на платформах, поддерживаемых виртуальной машиной, в байткод которой
	может быть оттранслирован исходный код приложения;
	\item предоставление отладочных возможностей: тот факт, что язык
	разработки мобильных приложений встроен в язык \name{Accord}, что
	означает их единство, гарантирует предоставление отладочных возможностей
	при разработке мобильных приложений в случае, если язык \name{Accord}
	имеет эти возможности. Несмотря на раннюю стадию разработки, язык
	\name{Accord} уже способен сохранять отладочную информацию о программе
	в формате \name{DWARF}~\cite{dwarf-homepage};
	\item поддержка интегрированной средой разработки: любая интегрированная
	среда разработки для языка \name{Accord} подходит и для разработки
	мобильных приложений на нём в силу единства языка разработки мобильных
	приложения и языка \name{Accord}.
\end{itemize}

Для достижения декларативности описания графического интерфейса в
спецификацию языка \name{Accord} были добавлены процедуры инициализации
объектов. На листинге~\ref{lst:accord-init} представлено упрощённое
синтаксическое правило определения процедур инициализации внутри
синтаксического контекста определения типа. Вызов процедуры инициализации
происходит автоматически при создании объекта во время выполнения программы.
Синтаксически данная семантика выглядит следующим образом:
\textit{TypeName(args)}, например, \textit{Text("This is an example")}.
\begin{lstlisting}[style=Antlr, caption=Синтаксическое правило процедур инициализации, label={lst:accord-init}]
INIT
	: 'init'
	;

type_init
	: INIT fn_params expression_sequence
	;
\end{lstlisting}

Для работы с реактивными данным в спецификацию языка \name{Accord} был
добавлен модификатор полей типов --- \textit{rx}. На данный момент, для
данных графической компоненты, помеченных модификатором \textit{rx},
компилятор автоматически генерирует функцию-мутатор. Задачей данной функции
является изменение реактивных данных и отметка необходимости обновления
графической компоненты, реактивные данные которой были изменены. В ходе
анализа графа потока управления, все изменения реактивных данных заменяются
на вызов сгенерированной функции-мутатора.
На листинге~\ref{lst:accord-rx-setter} представлен пример мутатора
реактивного поля \textit{counter} типа \textit{i32} компоненты
\textit{CounterComponent}.
\begin{lstlisting}[language=my_pseudo, caption=Пример функции-мутатора реактивных данных, label={lst:accord-rx-setter}]
fn CounterComponent.aco.set_counter(val: i32) {
    counter = val
    markNeedUpdate(this)
}
\end{lstlisting}
В дальнейшем семантика модификатора \textit{rx} будет расширена: он будет
применим не только к полям типов, но и к переменным. Изменение реактивных
данных будет приводить не только к обновлению графической комопненты на
экране, но и к обновлению других данных, как-либо использующих изменившиеся
реактивные данные.

\subsubsection{Статическая типизация графических компонент}
Различные графические компоненты могут сильно отличаться друг друга
семантически. Так, одни компоненты имеют динамическую
природу и могут изменяться от кадра к кадру, другие же --- статические ---
создаются лишь раз и не меняются на протяжении всей работы приложения.
Реальные графические компоненты, определяемые пользователем в приложении
могут быть достаточно сложными: включать большое количество различных
компонент, каждая из которых имеет своё собственное поведение и условия
обновления. Классический алгоритм обновления кадра, описанный
в главе~\ref{section:render-pipeline}, при условии поддержки компилятором,
использует статическую информацию о компонентах для минимизации
количества действий, необходимых для обновления кадра. Так, информация о
том, может ли компонента изменяться во время работы приложения, используется
средой времени исполнения для уменьшения количества сравнений
соответствующих компонент двух соседних кадров. Однако, знание таких
параметров, как тип и размер компоненты и её подкомпонент, а также
расположение подкомпонент относительно их родительской компоненты позволяет
избавиться от части операций, проводимых классическим алгоритмом во время
исполнения приложения ещё на этапе компиляции программы.

Рассмотрим пример графической компоненты на
листинге~\ref{lst:component-example}. Она представляет собой колонку,
состоящую из текста, кнопки и некоторой условной компоненты, которая
превращается в изображение или текст в зависимости от условия
\textit{condition}.
\begin{lstlisting}[language=my_pseudo, caption=Пример графической компоненты, label={lst:component-example}]
Column {
    Text("Current count: ${counter}")
    Button("Click on me!")
        .onClick(fn() { counter += 1 })
        .backgroundColor(Color.Green)
        .width(150px)
    ConditionalView(
        condition,
        Image("img.png"),
        Text("Empty")
    )
}
\end{lstlisting}
Зная статический тип данной компоненты
(листинг~\ref{lst:component-type-example}: $f0$ --- тип
под\-ком\-по\-ненты-колонки, $f1$ --- тип переменной \textit{counter}, $f2$
--- тип переменной \textit{condition}) и её представление в памяти
(рис.~\ref{component-layout-example}), компилятор способен ещё во время
компиляции приложения понять, какие компоненты могут быть изменены
во время работы приложения, а какие нет.
\begin{lstlisting}[escapeinside={(*}{*)}, caption=Пример статического типа компоненты, label={lst:component-type-example}]
struct {
    f0: Column[Text, Button, ConditionalView[Image, Text]]
    f1: i32
    f2: bool
}
\end{lstlisting}

\begin{figure}[H]
\centering
\MemoryLayout{
        32/blue!40/f0,
        40/green!40/f1,
        48/red!40/f2
}
\caption{Пример представления компоненты в памяти}
\label{component-layout-example}
\end{figure}
Имея представление компоненты в
памяти, компилятор может сгенерировать специализированную для конкретного
типа компоненты процедуру обновления
(листинг~\ref{lst:optimized-update-fn}). Эта процедура состоит из точечных
вызовов обновления только потенциально изменяемых во время работы приложения
компонент. Для сравнения такого подхода с классическим, введём понятия
некоторых условных операций, необходимых для обновления интерфейса согласно
главе~\ref{section:render-pipeline}. Пусть $A$ --- операция перехода между
узлами дерева компонент, $B$ --- проверка узла на изменяемость (проверка во
время исполнения программы), $C$ --- вызов процедуры обновления компоненты.
Тогда, если $N$ --- количество всех компонент, $M$ --- количество изменяемых
компонент, причём $M \leq N$, то для обновления одного кадра классическому
алгоритму необходимо произвести $(N - 1) * A + N * B + M * C$ операций,
в то время как описанному выше алгоритму лишь $M * C$.
\begin{lstlisting}[language=my_pseudo, caption=Пример сгенерированной процедуры обновления компоненты, label={lst:optimized-update-fn}]
fn Counter.rerender() {
    // skip Column
    Text.rerender(fieldAddress(0, 0), args...)
    // skip Button
    ConditionalView.rerender(
        fieldAddress(0, 2), args...,
    )
}
\end{lstlisting}
Для того, чтобы данная информация была доступна компилятору языка
\name{Accord}, в его спецификацию были добавлены синтаксис и семантика
наследования независимых типов (не имеющих типов-параметров) от
ненастроенных обобщённых типов с последующей автоматической настройкой
обобщённого типа-родителя в зависимости от содержимого определения
типа-потомка.

\subsection{Вывод}
Результатом выбора и реализации архитектурных решений, описанных в
пункте~\ref{section:architecture}, стало соответствие разработанного
решения всем требованиям, перечисленным в главе~\ref{requirements-section}.
