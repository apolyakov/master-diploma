\section{Архитектура и особенности реализации}
В данном разделе представлена общая архитектура решения и особенности реализации, позволившие решению удовлетворить всем требованиям к
современному языку разработки мобильных приложений, указанным в разделе~\ref{requirements-section}.

\subsection{Архитектура решения}
Начинать рассказ об архитектуре предлагаемого решения стоит с перечисления
основных концепций, лежащих в основе данного решения, с последующим
разъяснением каждой из них:
\begin{itemize}
	\item встраивание предметного языка разработки мобильных приложений
	в язык программирования общего назначения \textit{Accord};
	\item декларативное описание графического интерфейса;
	\item реактивность --- часть языка;
	\item статическая типизация всех графических компонент.
\end{itemize}

\subsubsection*{Встраивание в язык программирования \textit{Accord}}
В качестве метода реализации предметного языка разработки мобильных
приложений был выбран метод встраивания в базовый язык. Данный выбор был
сделан на основе рекомендаций по выбору подхода к созданию
предметно-ориентированного языка, представленного
в приложении~\ref{appendixA}.

Реализация предметно-ориентированного языка разработки мобильных приложений
методом встраивания данного предметного языка в базовый язык, которым в
данном случае выступает язык программирования \textit{Accord} сохраняет
преимущества и недостатки данного подхода, описанные в разделе~\ref{dsl-section}.
Однако, предметно-специфичные анализ, оптимизации и трансформации были
учтены на этапе проектирования данного решения, что нивелировало часть
недостатков подхода.

% написать пояснение к каждой развилке выбора на картинке

\subsubsection*{Декларативное описание графического интерфейса}
Как показано на листинге~\ref{lst:accord-example}, графический интерфейс
мобильного приложения на разработанном языке описывается декларативно.

\begin{lstlisting}[language=my_pseudo,caption=Счётчик нажатия кнопки на модифицированном языке \name{Accord},label={lst:accord-example}]
type Counter = struct (View[T]) {
    rx var counter: i32
    var cond: bool
    
    var body: T = Column(
        Text("Current count: ${this.counter}"),
        Button("Click on me!")
            .onClick(fn() { this.counter += 1 })
            .backgroundColor(Color.Green)
        ConditionalView(
            this.cond,
            Image("path/to/img"),
            Text("Condition is false")
        )
    )
}
\end{lstlisting}

\subsubsection*{Реактивность --- часть языка}
В язык программирования \textit{Accord} был добавлен модификатор
\textit{rx}, применимый к полям структурных типов и переменным. В контексте
отрисовки графического интерфейса, любая модификация данных графической
компоненты, помеченных данным модификатором, пометит компоненту как
"требующую обновление".

\subsection*{Статическая типизация всех графических компонент}
Поле body, определяемое на 5 строке, инициализируется выражением,
декларативно описывающим структуру графического интерфейса.
С точки зрения выполнения оптимизации отрисовки интерфейса, наиболее важным
является тот факт, что поле body имеет статический тип, который по
определению данного поля является обобщённым, однако при указании
конкретного значения, данный обобщённый тип будет настроен компилятором.
Применение обобщённых типов здесь позволяет пользователю не думать о том,
какой конкретно тип получит созданная им компонента, в то время как
компилятору данная информацию будет доступна после настройки обобщённого
типа.

Зная типовую информацию обо всех компонентах графического интерфейса
(включая их размеры и взаимное расположение в памяти), мы можем заменить
обход дерева элементов интерфейса на точечные вызовы процедур обновления
только для тех компонент, которые потенциально могут измениться во время
исполнения программы. Например, зная тип компоненты интерфейса
\textit{Counter}, мы можем точечно обратиться к каждому из его внутренних
подкомпонент при необходимости. Для приведённого примера, компилятор может
автоматически сгенерировать оптимизированную процедуру обновления
интерфейса~\ref{lst:accord-generated-update}, в которой изменению и проверке
будут подлежать лишь потенциально меняющиеся компоненты:
\begin{itemize}
	\item Нет необходимости проверять компоненту Column, она как была Column
	из текста, кнопки и некоторой условной компоненты, так и останется на
	протяжении всего исполнения программы
	\item Нет необходимости в проверке кнопки, поскольку она не зависит от
	потенциально изменяющихся данных
\end{itemize}

\begin{lstlisting}[language=my_pseudo,caption=Автоматически сгенерированная процедура обновления интерфейса,label={lst:accord-generated-update}]
fn Counter.rerender() {
    // skip Column
    Text.rerender(fieldAddress(0, 0), args...)
    // skip Button
    ConditionalView.rerender(
        fieldAddress(0, 2), args...,
    )
}
\end{lstlisting}